[[generate-java-from-wsdl]]
= Generate the Model classes from WSDL

`quarkus-cxf` extension supports generating Java classes from WSDL during Quarkus code generation phase.

[NOTE]
.Code examples
====
The code snippets shown in this section come from the
https://github.com/quarkiverse/quarkus-cxf/tree/main/integration-tests/client[client integration test]
in the source tree of {quarkus-cxf-project-name}.
You may want to check it as an executable example.
====

You need to set up a couple of things for CXF code generation to work:

* Have `io.quarkiverse.cxf:quarkus-cxf` dependency in your project
* For Maven projects, the `generate-code` goal needs to be present in the configuration of `quarkus-maven-plugin`:
+
.pom.xml
[source,xml]
----
include::example$calculator-client/pom.xml[tag=first-soap-client.adoc-quarkus-maven-plugin]
----
+
* For Gradle projects no additional configurarion of `io.quarkus` plugin is needed
* Put your WSDL files under `src/main/resources` or `src/test/resources` or any subdirectory thereof.
* Your WSDL file names must end with `.wsdl`
* Set `quarkus.cxf.codegen.wsdl2java.includes`
  xref:reference/extensions/quarkus-cxf.adoc#quarkus-cxf_quarkus-cxf-codegen-wsdl2java-includes[configuration property]
  to a pattern matching the WSDL files you wish to process.
  If you want to process all WSDL files under `src/main/resources/wsdl` or `src/test/resources/wsdl`, set it as follows:
+
.application.properties
[source,properties]
----
quarkus.cxf.codegen.wsdl2java.includes = wsdl/*.wsdl
----

This will generate Java classes in `target/generated-sources/wsdl2java` or
`target/generated-test-sources/wsdl2java` directory.
They will be automatically picked by the compiler plugin there.
Hence we are free to refer to them from our application or test code.

[NOTE]
====
Note that `quarkus-cxf` code generation uses the https://cxf.apache.org/docs/wsdl-to-java.html[wsdl2Java] utility
from CXF under the hood. `wsdl2Java` is called separately for each WSDL file selected by `includes` and `excludes`.
====

Passing custom parameters to `wsdl2java` is possible through
xref:reference/extensions/quarkus-cxf.adoc#quarkus-cxf_quarkus-cxf-codegen-wsdl2java-additional-params[`quarkus.cxf.codegen.wsdl2java.additional-params`]
configuration parameter.

If you need different `additional-params` for each WSDL file, you may want to define a separate named parameter set for
each one of them. Here is an example:

.application.properties
[source,properties]
----
# Parameters for foo.wsdl
quarkus.cxf.codegen.wsdl2java.foo-params.includes = wsdl/foo.wsdl
quarkus.cxf.codegen.wsdl2java.foo-params.wsdl-location = wsdl/foo.wsdl
# Parameters for bar.wsdl
quarkus.cxf.codegen.wsdl2java.bar-params.includes = wsdl/bar.wsdl
quarkus.cxf.codegen.wsdl2java.bar-params.wsdl-location = wsdl/bar.wsdl
quarkus.cxf.codegen.wsdl2java.bar-params.xjc = ts
----

[TIP]
====
Add `xref:reference/extensions/quarkus-cxf-xjc-plugins.adoc[io.quarkiverse.cxf:quarkus-cxf-xjc-plugins]` dependency to your project to be able to use
`-xjc-Xbg`, `-xjc-Xdv`, `-xjc-Xjavadoc`, `-xjc-Xproperty-listener`, `-xjc-Xts` and `-xjc-Xwsdlextension`
wsdl2java parameters.
====

[[Non-ASCII-Characters]]
== Non ASCII Characters
Sometimes the wsdl2java autogenerated Java classes may not be
fully compatible with GraalVM due to non ASCII characters getting included in the code.  Similar exceptions to
the below may appear during native image builds.

[source,bash]
----
[quarkus-dalkia-ticket-loader-1.0.0-SNAPSHOT-runner:26]      compile: 161 459,15 ms,  8,54 GB
[quarkus-dalkia-ticket-loader-1.0.0-SNAPSHOT-runner:26]        image: 158 272,73 ms,  8,43 GB
[quarkus-dalkia-ticket-loader-1.0.0-SNAPSHOT-runner:26]        write:     205,82 ms,  8,43 GB
Fatal error:com.oracle.svm.core.util.VMError$HostedError: java.lang.RuntimeException: oops : expected ASCII string! com.oracle.svm.reflect.OperationOrderStatusType_CRÉÉ_f151156b0d42ecdbdfb919501d8a86dda8733012_1456.hashCode
    at com.oracle.svm.core.util.VMError.shouldNotReachHere(VMError.java:72)
----

Below is an example of auto-generated non ASCII characters in a Java class:
[source,java]
----
@XmlType(name = "OperationOrderStatusType")
@XmlEnum
public enum OperationOrderStatusType {

    @XmlEnumValue("Cr\u00e9\u00e9")
    CRÉÉ("Cr\u00e9\u00e9"),
    @XmlEnumValue("A communiquer")
    A_COMMUNIQUER("A communiquer"),
    @XmlEnumValue("En attente de r\u00e9ponse")
    EN_ATTENTE_DE_RÉPONSE("En attente de r\u00e9ponse"),
    @XmlEnumValue("Attribu\u00e9")
    ATTRIBUÉ("Attribu\u00e9"),
    @XmlEnumValue("Clotur\u00e9")
    CLOTURÉ("Clotur\u00e9"),
    @XmlEnumValue("Annul\u00e9")
    ANNULÉ("Annul\u00e9");
    private final String value;

    OperationOrderStatusType(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static OperationOrderStatusType fromValue(String v) {
        for (OperationOrderStatusType c: OperationOrderStatusType.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }
}
----

Anything starting with `\u` will be a problem. Consequently the following refactoring is needed:

[source,java]
----
@XmlType(name = "OperationOrderStatusType")
@XmlEnum
public enum OperationOrderStatusType {

    @XmlEnumValue("Créé")
    CREE("Créé"),
    @XmlEnumValue("A communiquer")
    A_COMMUNIQUER("A communiquer"),
    @XmlEnumValue("En attente de réponse")
    EN_ATTENTE_DE_REPONSE("En attente de réponse"),
    @XmlEnumValue("Attribué")
    ATTRIBUE("Attribué"),
    @XmlEnumValue("Cloturé")
    CLOTURE("Cloturé"),
    @XmlEnumValue("Annulé")
    ANNULE("Annulé");
    private final String value;

    OperationOrderStatusType(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static OperationOrderStatusType fromValue(String v) {
        for (OperationOrderStatusType c: OperationOrderStatusType.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }
}
----


